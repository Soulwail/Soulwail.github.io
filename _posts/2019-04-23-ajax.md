---
layout: post
title: Ajax 知识体系大梳理
date: 2019-04-23
desc: "Ajax 知识体系"
keywords: "ajax"
categories: [Http]
tags: [Ajax]
icon:
---

原文：[http://louiszhai.github.io/2016/11/02/ajax/](http://louiszhai.github.io/2016/11/02/ajax/ "hp")

- [导读](#ID0)
- [浏览器为 Ajax 做了什么](#ID1)
  - [MSXML](#ID1-1)
  - [全平台兼容的 XMLHttpRequest 对象](#ID1-2)
- [Ajax 有没有破坏 js 单线程机制](#ID2)
- [Ajax 与 setTimeout 排队问题](#ID3)
- [XMLHttpRequest 属性解读](ID4)
  - [inherit](#ID4-1)
  - [readyState](#ID4-2)

## 导读 {#ID0}

Ajax 全称 Asynchronous JavaScript and XML，即异步 JS 与 XML。它最早在 IE5 中被使用，然后有Mozilla、Apple、Google 推广开来，典型的代表应用有 Outlook Web Access，以及 GMail。现代网页中几乎无 Ajax 不欢，前后端分离也正是建立在 Ajax 异步通信的基础上。

<br>

## 浏览器为 Ajax 做了什么 {#ID1}

现代浏览器中，虽然几乎全部支持 Ajax，但是它们的技术方案却分为两种：

① 标准浏览器通过 `XMLHttpRequest` 对象实现了 Ajax 的功能，只需要通过一行语句便可创建一个用于发送 Ajax 请求的对象。

~~~javascript
var xhr = new XMLHttpRequest();
~~~

② IE 浏览器通过 `XMLHttpRequest` 或者 `ActiveXObject` 对象同样实现了 Ajax 的功能。

### MSXML {#ID1-1}

鉴于 IE 系列各种“神级”表现，我们先来看看 IE 浏览器风骚的走位。

IE 下的使用环境略显复杂，IE7 及更高版本浏览器可以直接使用 BOM 的 `XMLHttpRequest` 对象，MSDN 传送门：[Native XMLHTTPRequest object](https://blogs.msdn.microsoft.com/ie/2006/01/23/native-xmlhttprequest-object/ "hp")。IE6 及更低版本浏览器只能使用 `ActiveXObject` 对象来创建 XMLHttpRequest 对象实例。创建时需要指明一个类似“Microsoft.XMLHTTP”这样的 ProgID，而实际上，在 windows 系统环境下，一下 ProgID 都应该可以创建 XMLHTTP 对象：

~~~javascript
Microsoft.XMLHTTP
Microsoft.XMLHTTP.1.0
Msxml2.ServerXMLHTTP
Msxml2.ServerXMLHTTP.3.0
Msxml2.ServerXMLHTTP.4.0
Msxml2.ServerXMLHTTP.5.0
Msxml2.ServerXMLHTTP.6.0
Msxml2.XMLHTTP
Msxml2.XMLHTTP.3.0
Msxml2.XMLHTTP.4.0
Msxml2.XMLHTTP.5.0
Msxml2.XMLHTTP.6.0
~~~

简而言之，Microsoft.XMLHTTP 已经非常老了，主要用于提供对历史遗留版本的支持，不建议使用。

对于 MSXML4，它已被 MSXML6 替代，而 MSXML5 又是针对 office 办公场景，在没有安装 Microsoft Office 2003 及更高版本办公软件的情况下，MSXML5 未必可用。相比之下，MSXML6 具有比 MSXML3 更稳定，更高性能，更安全的优势，同时它也提供一些 MSXML3 中没有的功能，比如说：XSD schema。

唯一遗憾的是，MSXML6 只在 vista 系统及以上才是默认支持的；而 MSXML3 在 Win2k SP4 及以上系才是可用的。因此一般情况下，MSXML3 可以作为 MSXML6 的优雅降级方案，我们通过指定 ProgID 为 Msxml2.XMLHTTP 即可自动映射到 Msxml2.XMLHTTP.3.0。如下所示：

~~~javascript
var xhr = new ActiveXObject("Msxml2.XMLHTTP"); // 即 MSXML3，等同于如下语句
var xhr = new ActiveXObject("MSXML2.HTTP.3.0");
~~~

MSDN 有篇文章，专门讲解了各个版本的 MSXML。传送门：[Using the right version of MSXML in Internet Explorer](https://blogs.msdn.microsoft.com/xmlteam/2006/10/23/using-the-right-version-of-msxml-in-internet-explorer/)。

亲测了 IE5，IE5.5，IE6，IE7，IE8，IE9，IE10，IE edge 等浏览器，IE5 及之后的浏览器均可通过如下语句获取 xhr 对象：

~~~javascript
var xhr = new ActiveXObject("Msxml2.XMLHTTP"); // 即 MSXML3
var xhr = new ActiveXObject("Microsoft.XMLHTTP"); // 很老的 api，虽然浏览器支持，功能可能不完善，故不建议使用
~~~

以上，思路已经很清晰了，下面给出了全兼容的方法。

### 全平台兼容的 XMLHttpRequest 对象 {#ID1-2}

~~~javascript
function getXHR() {
  var xhr = null;
  if (window.XMLHttpRequest) {
    xhr = new XMLHttpRequest();
  } else if (window.ActiveXObject) {
    try {
      xhr = new ActiveXObject("Msxml2.XMLHTTP");
    } catch (e) {
      try {
        xhr = new ActiveXObject("Microsoft.XMLHTTP");
      } catch (e) {
        alert("您的浏览器暂不支持 Ajax！");
      }
    }
  }
  return xhr;
}
~~~

<br>

## Ajax 有没有破坏 js 单线程机制 {#ID2}

对于这个问题，我们先看下浏览器线程机制。一般情况下，浏览器有如下四种线程：

- GUI 渲染线程
- JavaScript 引擎线程
- 浏览器事件触发线程
- HTTP 请求线程

那么这么多线程，它们究竟是怎么同 js 引擎线程交互的呢？

通常，它们的线程间交互以事件的方式发生，通过事件回调的方式予以通知。而事件回调，又是以先进先出的方式添加到 `任务队列` 的末尾，等到 js 引擎空闲时，`任务队列` 中排队的任务将会依次被执行，这些事件回调包括 setTimeout、setInterval、click、ajax 异步请求等回调。

**浏览器中，js 引擎线程会循环从 `任务队列` 中读取事件并且执行，这种运行机制称作 `Event Lop`（事件循环）。**

对于一个 ajax 请求，js 引擎首先生成 `XMLHttpRequest` 实例对象，open 过后再调用 send 方法。至此，所有的语句都是同步执行。但从 send 方法内部开始，浏览器为将要发生的网络请求创建了新的 http 请求线程，这个线程独立于 js 引擎线程，于是网络请求异步被发送出去了。另一方面，js 引擎并不会等待 ajax 发起的 http 请求收到结果，而是直接顺序往下执行。

当 ajax 请求被服务器响应并且受到 response 后，浏览器事件触发线程捕获到了 ajax 的回调事件 `onreadystatechange`（当然也可能触发 `onload`，或者 `onerror` 等等）。该回调事件并没有被立即执行，而是被添加到 `任务队列` 的末尾，直到 js 引擎空闲了，`任务队列` 的任务才被捞出来，按照添加顺序，挨个执行，当然也包括刚刚 append 到队列末尾的 `onreadystatechange` 事件。

在 `onreadystatechange` 事件内部，有可能对 dom 进行操作，此时浏览器便会挂起 js 引擎线程，转而执行 GUI 渲染线程，进行 UI 重绘（repaint）或者回流（reflow）。当 js 引擎重新执行时，GUI 渲染线程又会被挂起，GUI 更新将被保存起来，等到 js 引擎空闲时立即被执行。

以上整个 ajax 请求过程中，有涉及到浏览器的 4 种线程，其中除了 `GUI 渲染线程` 和 `js 引擎线程`，其他线程相互之间，都是可以并行执行的。通过这样的一种方式，ajax 并没有破坏 js 的单线程机制。

<br>

## Ajax 与 setTimeout 排队问题 {#ID3}

通常，ajax 和 setTimeout 的事件回调都被同等的对待，按照顺序自动的被添加到 `任务队列` 的末尾，等待 js 引擎空闲时执行。但请注意，并非 xhr 的所有回调执行都滞后于 setTimeout 的回调。请看如下代码：

~~~javascript
function ajax(url, method) {
  var xhr = getXHR();

  xhr.onreadystatechange = function () {
    console.log('xhr.readyState' + this.readyState);
  }
  xhr.onloadstart = function () {
    console.log('onloadStart');
  }
  xhr.onload = function () {
    console.log('onload');
  }
  xhr.open(method, url, true);
  xhr.setRequestHeader('Cache-Control', 3600);
  xhr.send();
}

var timer = setTimeout(function () {
  console.log('setTimeout');
}, 0);

ajax('https://user-gold-cdn.xitu.io/2017/3/15/c6eacd7c2f4307f34cd45e93885d1cb6.png', 'GET');
console.warn('这里的 log 并不是最先打印出来的。');
~~~

上述代码执行结果如下图：

![setTimeout & ajax & 同步](https://github.com/Soulwail/Soulwail.github.io/raw/master/image_files/ajax_00.png)

由于 ajax 异步，setTimeout 回调本应该最先被执行的，然而实际上，一次 ajax 请求，并非所有的部分都是异步的，至少 "readyState == 1" 的 `onreadystatechange` 回调以及 `onloadstart` 回调就是同步执行的，因此它们的输出排在最前面。

<br>

## XMLHttpRequest 属性解读 {#ID4}

首先在 Chrome console 下创建一个 XMLHttpRequest 实例对象 xhr。如下所示：

![XMLHttpRequest](https://github.com/Soulwail/Soulwail.github.io/raw/master/image_files/ajax_01.png)

### inherit {#ID4-1}

试运行一下代码。

~~~javascript
var xhr = new XMLHttpRequest(), i = 0;

for (var key in xhr) {
  if (xhr.hasOwnProperty(key)) {
    i++;
  }
}

console.log(i); // 0
console.log(XMLHttpRequest.prototype.hasOwnProperty('timeout')); // true
~~~

可见 XMLHttpRequest 实例对象没有自由属性。实际上，它的所有属性均来自于 `XMLHttpRequest.prototype`。

追根溯源，XMLHttpRequest 实例对象具有如下的继承关系。（下面以 a << b 表示 a 继承 b）

`xhr` << `XMLHttpRequest.prototype` << `XMLHttpRequestEventTarget.prototype` << `EventTarget.prototype` << `Object.prototype`

由上，xhr 也具有 Object 等原型中的所有方法，如 toString 方法。

~~~javascript
xhr.toString(); // "[object XMLHttpRequest]"
~~~

通常，一个 xhr 实例对象拥有 10 个普通属性和 9 个方法。

### readyState {#ID4-2}

只读属性，readyState 属性记录了 ajax 调用过程中所有可能的状态。它的取值简单明了，如下：

|readyState|对应常量|描述|
|---|---|---|
| 0 (未初始化)|xhr.UNSENT|请求已建立，但未初始化（此时未调用 open 方法）|
| 1 (初始化)|xhr.OPENED|请求已建立，但未发送（已调用 open 方法，但未调用 send 方法）|
| 2 (发送数据)|xhr.HEADRS_RECEIVED|请求已发送（send 方法已调用，已收到响应头）|
| 3 (数据传送中)|xhr.LOADING|请求处理中，因响应内容不全，这时通过 responseBody 和 responseText 获取可能会出现错误|
| 4 (完成)|xhr.DONE|数据接受完毕，此时可以通过 responseBody 和 responseText 获取完整的响应数据|

注意，readyState 是一个只读属性，想要改变它的值是不可行的。
